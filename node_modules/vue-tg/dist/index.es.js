import { defineComponent as u, onMounted as m, watch as b, onUnmounted as v, ref as r, readonly as p, computed as l, openBlock as f, createBlock as B, resolveDynamicComponent as A, withCtx as S } from "vue";
const Ae = /* @__PURE__ */ u({
  __name: "Alert",
  props: {
    message: {
      type: String,
      required: !0
    }
  },
  emits: ["close"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showAlert: a } = k();
    return m(() => a(t.message, () => n("close"))), (i, s) => null;
  }
}), Te = /* @__PURE__ */ u({
  __name: "BackButton",
  props: {
    visible: { type: Boolean, default: !0 }
  },
  emits: ["click"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showBackButton: a, onBackButtonClicked: i, hideBackButton: s } = Re();
    return b(
      () => t.visible,
      (d) => {
        d ? a() : s();
      }
    ), i(() => n("click")), m(() => t.visible && a()), v(() => s()), (d, h) => null;
  }
}), he = /* @__PURE__ */ u({
  __name: "BiometricManager",
  emits: ["init"],
  setup(e, { emit: o }) {
    const t = o, { initBiometric: n } = ze();
    return m(() => n(() => t("init"))), (a, i) => null;
  }
}), ve = /* @__PURE__ */ u({
  __name: "ClosingConfirmation",
  setup(e) {
    const { enableClosingConfirmation: o, disableClosingConfirmation: t } = Oe();
    return m(() => o()), v(() => t()), (n, a) => null;
  }
}), We = /* @__PURE__ */ u({
  __name: "Confirm",
  props: {
    message: { type: String, required: !0 }
  },
  emits: ["close"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showConfirm: a } = k();
    return m(() => a(t.message, (i) => n("close", i))), (i, s) => null;
  }
}), Se = /* @__PURE__ */ u({
  __name: "ExpandedViewport",
  props: {
    force: { type: Boolean, default: !1 }
  },
  setup(e) {
    const o = e, { onViewportChanged: t, expand: n } = Tt();
    return t(({ isStateStable: a }) => {
      o.force && a && n();
    }), m(() => n()), (a, i) => null;
  }
}), Ce = /* @__PURE__ */ u({
  __name: "MainButton",
  props: {
    text: { type: String },
    color: { type: String },
    textColor: { type: String },
    visible: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    progress: { type: Boolean, default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: o }) {
    const t = e, n = o, {
      setMainButtonParams: a,
      onMainButtonClicked: i,
      hideMainButton: s,
      showMainButtonProgress: d,
      hideMainButtonProgress: h
    } = et();
    return b(
      () => t.text,
      (c) => {
        a({
          text: c
        });
      }
    ), b(
      () => t.color,
      (c) => {
        a({
          color: c
        });
      }
    ), b(
      () => t.textColor,
      (c) => {
        a({
          text_color: c
        });
      }
    ), b(
      () => t.visible,
      (c) => {
        a({
          is_visible: c
        });
      }
    ), b(
      () => t.disabled,
      (c) => {
        a({
          is_active: !c
        });
      }
    ), b(
      () => t.progress,
      (c) => {
        c ? d() : h();
      }
    ), i(() => n("click")), m(() => {
      t.progress ? d() : h(), a({
        text: t.text,
        text_color: t.textColor,
        color: t.color,
        is_active: !t.disabled,
        is_visible: t.visible
      });
    }), v(() => {
      h(), s();
    }), (c, yt) => null;
  }
}), ke = /* @__PURE__ */ u({
  __name: "Popup",
  props: {
    title: { type: String },
    message: { type: String, required: !0 },
    buttons: { type: Array }
  },
  emits: ["close"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showPopup: a } = k();
    return m(
      () => a(
        {
          title: t.title,
          message: t.message,
          buttons: t.buttons
        },
        (i) => n("close", i)
      )
    ), (i, s) => null;
  }
}), {
  initData: ye,
  initDataUnsafe: Me,
  version: xe,
  platform: we,
  isVersionAtLeast: Pe,
  sendData: _e,
  close: qe
} = Telegram.WebApp, z = r(!1), Ee = (...e) => {
  Telegram.WebApp.ready(...e), z.value = !0;
}, V = (e) => Telegram.WebApp.platform === e, O = V("unknown"), $e = !O && Telegram.WebApp.initData === "";
function g() {
  return {
    initData: ye,
    initDataUnsafe: Me,
    version: xe,
    platform: we,
    isVersionAtLeast: Pe,
    onEvent: (o, t, n = { manual: !1 }) => {
      const { manual: a } = n, i = () => {
        Telegram.WebApp.onEvent(
          o,
          t
        );
      }, s = () => {
        Telegram.WebApp.offEvent(
          o,
          t
        );
      };
      return a ? i() : (m(i), v(s)), {
        off: s
      };
    },
    sendData: _e,
    ready: Ee,
    close: qe,
    isReady: p(z),
    isPlatform: V,
    isPlatformUnknown: O,
    canSendData: $e
  };
}
const j = r(Telegram.WebApp.BackButton.isVisible);
function N() {
  j.value = Telegram.WebApp.BackButton.isVisible;
}
function M(...e) {
  Telegram.WebApp.BackButton.show(...e), N();
}
function x(...e) {
  Telegram.WebApp.BackButton.hide(...e), N();
}
function Re() {
  const { onEvent: e } = g(), o = (t, n) => e("backButtonClicked", t, n);
  return {
    isBackButtonVisible: l({
      get() {
        return j.value;
      },
      set(t) {
        t ? M() : x();
      }
    }),
    onBackButtonClicked: o,
    showBackButton: M,
    hideBackButton: x
  };
}
const {
  init: De,
  requestAccess: Ie,
  authenticate: Ue,
  updateBiometricToken: He,
  openSettings: Le
} = Telegram.WebApp.BiometricManager, J = r(Telegram.WebApp.BiometricManager.isInited), G = r(
  Telegram.WebApp.BiometricManager.isBiometricAvailable
), F = r(Telegram.WebApp.BiometricManager.biometricType), K = r(
  Telegram.WebApp.BiometricManager.isAccessRequested
), X = r(
  Telegram.WebApp.BiometricManager.isAccessGranted
), Y = r(
  Telegram.WebApp.BiometricManager.isAccessGranted
), Z = r(Telegram.WebApp.BiometricManager.deviceId);
function Qe() {
  J.value = Telegram.WebApp.BiometricManager.isInited, G.value = Telegram.WebApp.BiometricManager.isBiometricAvailable, F.value = Telegram.WebApp.BiometricManager.biometricType, K.value = Telegram.WebApp.BiometricManager.isAccessRequested, X.value = Telegram.WebApp.BiometricManager.isAccessGranted, Z.value = Telegram.WebApp.BiometricManager.deviceId, Y.value = Telegram.WebApp.BiometricManager.isBiometricTokenSaved;
}
function ze() {
  const { onEvent: e } = g(), o = (a, i) => e("biometricManagerUpdated", a, i), t = (a, i) => e("biometricAuthRequested", a, i), n = (a, i) => e("biometricTokenUpdated", a, i);
  return o(Qe), {
    isBiometricInited: p(J),
    isBiometricAvailable: p(G),
    biometricType: p(F),
    isBiometricAccessRequested: p(K),
    isBiometricAccessGranted: p(X),
    isBiometricTokenSaved: p(Y),
    biometricDeviceId: p(Z),
    initBiometric: De,
    requestBiometricAccess: Ie,
    authenticateBiometric: Ue,
    updateBiometricToken: He,
    openBiometricSettings: Le,
    onBiometricManagerUpdated: o,
    onBiometricAuthRequested: t,
    onBiometricTokenUpdated: n
  };
}
const { readTextFromClipboard: Ve } = Telegram.WebApp;
function xt() {
  const { onEvent: e } = g();
  return {
    readTextFromClipboard: Ve,
    onClipboardTextReceived: (t, n) => e("clipboardTextReceived", t, n)
  };
}
const ee = r(
  Telegram.WebApp.isClosingConfirmationEnabled
);
function te() {
  ee.value = Telegram.WebApp.isClosingConfirmationEnabled;
}
function w(...e) {
  Telegram.WebApp.enableClosingConfirmation(...e), te();
}
function P(...e) {
  Telegram.WebApp.disableClosingConfirmation(...e), te();
}
function Oe() {
  return {
    isClosingConfirmationEnabled: l({
      get() {
        return ee.value;
      },
      set(e) {
        e ? w() : P();
      }
    }),
    enableClosingConfirmation: w,
    disableClosingConfirmation: P
  };
}
const W = Telegram.WebApp.CloudStorage;
function je(e, o) {
  return new Promise((t, n) => {
    W.setItem(e, o, (a, i) => {
      a && n(a), t(i);
    });
  });
}
function Ne(e) {
  return new Promise((o, t) => {
    W.getItem(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function Je(e) {
  return new Promise((o, t) => {
    W.getItems(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function Ge(e) {
  return new Promise((o, t) => {
    W.removeItem(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function Fe(e) {
  return new Promise((o, t) => {
    W.removeItems(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function Ke() {
  return new Promise((e, o) => {
    W.getKeys((t, n) => {
      t && o(t), e(n);
    });
  });
}
function wt() {
  return {
    setStorageItem: je,
    getStorageItem: Ne,
    getStorageItems: Je,
    removeStorageItem: Ge,
    removeStorageItems: Fe,
    getStorageKeys: Ke
  };
}
const { impactOccurred: Xe, notificationOccurred: Ye, selectionChanged: Ze } = Telegram.WebApp.HapticFeedback;
function Pt() {
  return {
    impactOccurred: Xe,
    notificationOccurred: Ye,
    selectionChanged: Ze
  };
}
const ne = r(Telegram.WebApp.MainButton.text), oe = r(Telegram.WebApp.MainButton.color), ae = r(Telegram.WebApp.MainButton.textColor), ie = r(Telegram.WebApp.MainButton.isVisible), re = r(Telegram.WebApp.MainButton.isActive), se = r(
  Telegram.WebApp.MainButton.isProgressVisible
);
function T() {
  ne.value = Telegram.WebApp.MainButton.text, oe.value = Telegram.WebApp.MainButton.color, ae.value = Telegram.WebApp.MainButton.textColor, ie.value = Telegram.WebApp.MainButton.isVisible, re.value = Telegram.WebApp.MainButton.isActive, se.value = Telegram.WebApp.MainButton.isProgressVisible;
}
function _(...e) {
  Telegram.WebApp.MainButton.setText(...e), T();
}
function q(...e) {
  Telegram.WebApp.MainButton.show(...e), T();
}
function E(...e) {
  Telegram.WebApp.MainButton.hide(...e), T();
}
function $(...e) {
  Telegram.WebApp.MainButton.enable(...e), T();
}
function R(...e) {
  Telegram.WebApp.MainButton.disable(...e), T();
}
function D(...e) {
  Telegram.WebApp.MainButton.showProgress(...e), T();
}
function I(...e) {
  Telegram.WebApp.MainButton.hideProgress(...e), T();
}
function C(...e) {
  Telegram.WebApp.MainButton.setParams(...e), T();
}
function et() {
  const { onEvent: e } = g(), o = (t, n) => e("mainButtonClicked", t, n);
  return {
    mainButtonText: l({
      get() {
        return ne.value;
      },
      set(t) {
        _(t);
      }
    }),
    mainButtonColor: l({
      get() {
        return oe.value;
      },
      set(t) {
        C({
          color: t
        });
      }
    }),
    mainButtonTextColor: l({
      get() {
        return ae.value;
      },
      set(t) {
        C({
          text_color: t
        });
      }
    }),
    isMainButtonVisible: l({
      get() {
        return ie.value;
      },
      set(t) {
        t ? q() : E();
      }
    }),
    isMainButtonActive: l({
      get() {
        return re.value;
      },
      set(t) {
        t ? $() : R();
      }
    }),
    isMainButtonProgressVisible: l({
      get() {
        return se.value;
      },
      set(t) {
        t ? D() : I();
      }
    }),
    setMainButtonText: _,
    onMainButtonClicked: o,
    showMainButton: q,
    hideMainButton: E,
    enableMainButton: $,
    disableMainButton: R,
    showMainButtonProgress: D,
    hideMainButtonProgress: I,
    setMainButtonParams: C
  };
}
const { switchInlineQuery: tt, openLink: nt, openTelegramLink: ot, openInvoice: at } = Telegram.WebApp;
function _t() {
  const { onEvent: e } = g();
  return {
    switchInlineQuery: tt,
    openLink: nt,
    openTelegramLink: ot,
    openInvoice: at,
    onInvoiceClosed: (t, n) => e("invoiceClosed", t, n)
  };
}
const { showPopup: it, showAlert: rt, showConfirm: st } = Telegram.WebApp;
function k() {
  const { onEvent: e } = g();
  return {
    showPopup: it,
    showAlert: rt,
    showConfirm: st,
    onPopupClosed: (t, n) => e("popupClosed", t, n)
  };
}
const { showScanQrPopup: ct, closeScanQrPopup: lt } = Telegram.WebApp;
function ut() {
  const { onEvent: e } = g();
  return {
    showScanQrPopup: ct,
    closeScanQrPopup: lt,
    onQrTextReceived: (t, n) => e("qrTextReceived", t, n)
  };
}
const { requestContact: pt, requestWriteAccess: mt } = Telegram.WebApp;
function qt() {
  const { onEvent: e } = g();
  return {
    requestContact: pt,
    onContactRequested: (n, a) => e("contactRequested", n, a),
    requestWriteAccess: mt,
    onWriteAccessRequested: (n, a) => e("writeAccessRequested", n, a)
  };
}
const { initData: gt, initDataUnsafe: dt, sendData: bt, close: ft } = g();
function Et(e, o) {
  const t = o.serialize ?? JSON.stringify, n = r(""), a = (s) => {
    n.value = s, console.error(s);
  }, i = r(!1);
  return {
    error: n,
    isLoading: i,
    execute: () => {
      bt(t(e)), setTimeout(
        () => a(
          "Telegram.WebApp.sendData is only available for custom keyboards."
        ),
        1e3
      );
    },
    executeHttp: async (s, d = {}) => {
      const h = d.closeAfter ?? !0;
      i.value = !0;
      try {
        const c = await fetch(s, {
          method: "POST",
          body: JSON.stringify({
            initData: gt,
            initDataUnsafe: dt,
            data: t(e)
          })
        });
        return c.ok || a(`${c.status} ${c.statusText}`), c.ok && h && ft(), c;
      } catch (c) {
        a(String(c));
      } finally {
        i.value = !1;
      }
    }
  };
}
const ce = r(Telegram.WebApp.SettingsButton.isVisible);
function le() {
  ce.value = Telegram.WebApp.SettingsButton.isVisible;
}
function U(...e) {
  Telegram.WebApp.SettingsButton.show(...e), le();
}
function H(...e) {
  Telegram.WebApp.SettingsButton.hide(...e), le();
}
function Bt() {
  const { onEvent: e } = g(), o = (t, n) => e("settingsButtonClicked", t, n);
  return {
    isSettingsButtonVisible: l({
      get() {
        return ce.value;
      },
      set(t) {
        t ? U() : H();
      }
    }),
    onSettingsButtonClicked: o,
    showSettingsButton: U,
    hideSettingsButton: H
  };
}
const ue = r(Telegram.WebApp.colorScheme), pe = r(Telegram.WebApp.themeParams), me = r(Telegram.WebApp.headerColor), ge = r(Telegram.WebApp.backgroundColor);
function y() {
  ue.value = Telegram.WebApp.colorScheme, pe.value = {
    ...Telegram.WebApp.themeParams
  }, me.value = Telegram.WebApp.headerColor, ge.value = Telegram.WebApp.backgroundColor;
}
function L(...e) {
  Telegram.WebApp.setHeaderColor(...e), y();
}
function Q(...e) {
  Telegram.WebApp.setBackgroundColor(...e), y();
}
function $t() {
  const { onEvent: e } = g(), o = (t, n) => e("themeChanged", t, n);
  return o(y), {
    colorScheme: p(ue),
    themeParams: p(pe),
    headerColor: l({
      get() {
        return me.value;
      },
      set(t) {
        L(t);
      }
    }),
    backgroundColor: l({
      get() {
        return ge.value;
      },
      set(t) {
        Q(t);
      }
    }),
    setHeaderColor: L,
    setBackgroundColor: Q,
    onThemeChanged: o
  };
}
const de = r(Telegram.WebApp.isExpanded), be = r(Telegram.WebApp.viewportHeight), fe = r(Telegram.WebApp.viewportStableHeight);
function Be() {
  de.value = Telegram.WebApp.isExpanded, be.value = Telegram.WebApp.viewportHeight, fe.value = Telegram.WebApp.viewportStableHeight;
}
function At(...e) {
  Telegram.WebApp.expand(...e), Be();
}
function Tt() {
  const { onEvent: e } = g(), o = (t, n) => e("viewportChanged", t, n);
  return o(Be), {
    isExpanded: p(de),
    viewportHeight: p(be),
    viewportStableHeight: p(fe),
    expand: At,
    onViewportChanged: o
  };
}
const ht = /* @__PURE__ */ u({
  __name: "ScanQr",
  props: {
    text: { type: String }
  },
  emits: ["result"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showScanQrPopup: a, closeScanQrPopup: i } = ut();
    return m(
      () => a(
        {
          text: t.text
        },
        (s) => n("result", s)
      )
    ), v(() => i()), (s, d) => null;
  }
}), vt = /* @__PURE__ */ u({
  __name: "SettingsButton",
  props: {
    visible: { type: Boolean, default: !0 }
  },
  emits: ["click"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showSettingsButton: a, onSettingsButtonClicked: i, hideSettingsButton: s } = Bt();
    return b(
      () => t.visible,
      (d) => {
        d ? a() : s();
      }
    ), i(() => n("click")), m(() => t.visible && a()), v(() => s()), (d, h) => null;
  }
}), Wt = /* @__PURE__ */ u({
  __name: "ShareWidget",
  props: {
    url: {
      type: String,
      required: !0
    },
    comment: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    noLabel: {
      type: Boolean,
      default: !1
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const o = e, t = l(() => JSON.stringify(o));
    return (n, a) => (f(), B(A(e.tag), { key: t.value }, {
      default: S(() => [
        (f(), B(A("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-share-url": e.url,
          "data-size": e.size,
          "data-comment": e.comment,
          "data-text": e.noLabel ? "notext" : null
        }, null, 8, ["data-telegram-share-url", "data-size", "data-comment", "data-text"]))
      ]),
      _: 1
    }));
  }
}), St = /* @__PURE__ */ u({
  __name: "PostWidget",
  props: {
    url: {
      type: String,
      required: !0
    },
    width: {
      type: String,
      default: null
    },
    authorPhoto: {
      type: Boolean,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    darkColor: {
      type: String,
      default: null
    },
    dark: {
      type: Boolean,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const o = e, t = l(() => JSON.stringify(o));
    return (n, a) => (f(), B(A(e.tag), { key: t.value }, {
      default: S(() => [
        (f(), B(A("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-post": e.url,
          "data-width": e.width,
          "data-userpic": e.authorPhoto,
          "data-color": e.color,
          "data-dark-color": e.darkColor,
          "data-dark": e.dark
        }, null, 8, ["data-telegram-post", "data-width", "data-userpic", "data-color", "data-dark-color", "data-dark"]))
      ]),
      _: 1
    }));
  }
}), Ct = /* @__PURE__ */ u({
  __name: "LoginWidget",
  props: {
    botUsername: {
      type: String,
      required: !0
    },
    redirectUrl: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    cornerRadius: {
      type: String,
      default: null
    },
    userPhoto: {
      type: Boolean,
      default: null
    },
    requestWrite: {
      type: Boolean,
      default: !1
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: ["auth"],
  setup(e, { emit: o }) {
    const t = e, n = l(() => JSON.stringify(t)), a = o;
    return m(() => {
      window.onTelegramAuth = (i) => a("auth", i);
    }), (i, s) => (f(), B(A(e.tag), { key: n.value }, {
      default: S(() => [
        (f(), B(A("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-login": e.botUsername,
          "data-size": e.size,
          "data-radius": e.cornerRadius,
          "data-userpic": e.userPhoto,
          "data-request-access": e.requestWrite ? "write" : null,
          "data-onauth": e.redirectUrl ? null : "onTelegramAuth(user)",
          "data-auth-url": e.redirectUrl
        }, null, 8, ["data-telegram-login", "data-size", "data-radius", "data-userpic", "data-request-access", "data-onauth", "data-auth-url"]))
      ]),
      _: 1
    }));
  }
}), kt = /* @__PURE__ */ u({
  __name: "DiscussionWidget",
  props: {
    url: {
      type: String,
      required: !0
    },
    commentsLimit: {
      type: Number,
      default: null
    },
    height: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    darkColor: {
      type: String,
      default: null
    },
    dark: {
      type: Boolean,
      default: null
    },
    colorful: {
      type: Boolean,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const o = e, t = l(() => JSON.stringify(o));
    return (n, a) => (f(), B(A(e.tag), { key: t.value }, {
      default: S(() => [
        (f(), B(A("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-discussion": e.url,
          "data-comments-limit": e.commentsLimit,
          "data-height": e.height,
          "data-color": e.color,
          "data-dark-color": e.darkColor,
          "data-dark": e.dark,
          "data-colorful": e.colorful
        }, null, 8, ["data-telegram-discussion", "data-comments-limit", "data-height", "data-color", "data-dark-color", "data-dark", "data-colorful"]))
      ]),
      _: 1
    }));
  }
}), Rt = {
  install(e) {
    e.component("TgAlert", Ae), e.component("TgBackButton", Te), e.component("TgBiometricManager", he), e.component("TgClosingConfirmation", ve), e.component("TgConfirm", We), e.component("TgExpandedViewport", Se), e.component("TgMainButton", Ce), e.component("TgPopup", ke), e.component("TgScanQr", ht), e.component("TgSettingsButton", vt), e.component("TgShareWidget", Wt), e.component("TgPostWidget", St), e.component("TgLoginWidget", Ct), e.component("TgDiscussionWidget", kt);
  }
};
export {
  Ae as Alert,
  Te as BackButton,
  he as BiometricManager,
  ve as ClosingConfirmation,
  We as Confirm,
  kt as DiscussionWidget,
  Se as ExpandedViewport,
  Ct as LoginWidget,
  Ce as MainButton,
  ke as Popup,
  St as PostWidget,
  ht as ScanQr,
  vt as SettingsButton,
  Wt as ShareWidget,
  Rt as default,
  g as useWebApp,
  Re as useWebAppBackButton,
  ze as useWebAppBiometricManager,
  xt as useWebAppClipboard,
  Oe as useWebAppClosingConfirmation,
  wt as useWebAppCloudStorage,
  Pt as useWebAppHapticFeedback,
  et as useWebAppMainButton,
  _t as useWebAppNavigation,
  k as useWebAppPopup,
  ut as useWebAppQrScanner,
  qt as useWebAppRequests,
  Et as useWebAppSendData,
  Bt as useWebAppSettingsButton,
  $t as useWebAppTheme,
  Tt as useWebAppViewport
};
